name: Auto-Generate PDFs from ChordPro Files

on:
  push:
    paths:
      - '**/*.chopro'
      - '**/*.cho'
    branches: [ main, master ]
  workflow_dispatch:  # Allows manual triggering from GitHub Actions tab

# Sets permissions to allow committing generated PDFs back to the repo
permissions:
  contents: write
  actions: read

env:
  FORCE_COLOR: 1

jobs:
  generate-missing-pdfs:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0  # Fetch full history to handle multi-commit pushes
    
    - name: Check if PDFs need generation
      id: check-pdfs
      run: |
        echo "üîç Finding changed ChordPro files in push..."
        
        # Get list of changed ChordPro files across all commits in this push
        # Use the range from the push event, or fall back to HEAD^ for single commits
        if [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
          # Multi-commit push: compare against the push's base commit
          CHANGED_CHOPRO=$(git diff --name-only --diff-filter=AM ${{ github.event.before }}..HEAD | grep -E '\.(chopro|cho)' || true)
          echo "üìä Comparing ${{ github.event.before }}..HEAD (multi-commit push)"
          GIT_RANGE="${{ github.event.before }}..HEAD"
        else
          # New branch or initial commit: compare against HEAD^
          CHANGED_CHOPRO=$(git diff --name-only --diff-filter=AM HEAD^ HEAD | grep -E '\.(chopro|cho)' || true)
          echo "üìä Comparing HEAD^..HEAD (single commit or new branch)"
          GIT_RANGE="HEAD^..HEAD"
        fi
        
        if [ -z "$CHANGED_CHOPRO" ]; then
          echo "‚ÑπÔ∏è No ChordPro files changed in this push"
          echo "need_pdfs=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        echo "üìù Changed ChordPro files:"
        echo "$CHANGED_CHOPRO"
        
        # Check if any PDFs actually need generation
        PDFS_NEEDED=""
        echo "$CHANGED_CHOPRO" > /tmp/changed_chopro.txt
        while IFS= read -r chopro_file; do
          if [ -z "$chopro_file" ] || [ ! -f "$chopro_file" ]; then
            continue
          fi
          
          echo "üéµ Checking: $chopro_file"
          
          # Determine expected PDF path
          pdf_file="${chopro_file%.*}.pdf"
          
          # Check if PDF needs regeneration based on commit order
          PDF_IN_PUSH=$(git diff --name-only --diff-filter=AM $GIT_RANGE | grep "^${pdf_file}$" || true)
          
          if [ -n "$PDF_IN_PUSH" ]; then
            # PDF was modified in this push - check which came last
            CHOPRO_LAST_COMMIT=$(git log --format="%H" $GIT_RANGE -- "$chopro_file" | head -1)
            PDF_LAST_COMMIT=$(git log --format="%H" $GIT_RANGE -- "$pdf_file" | head -1)
            
            if [ -n "$PDF_LAST_COMMIT" ] && [ -n "$CHOPRO_LAST_COMMIT" ]; then
              # Compare commit timestamps to see which is newer
              CHOPRO_TIME=$(git show --format="%ct" --no-patch "$CHOPRO_LAST_COMMIT")
              PDF_TIME=$(git show --format="%ct" --no-patch "$PDF_LAST_COMMIT")
              
              if [ "$PDF_TIME" -ge "$CHOPRO_TIME" ]; then
                echo "  ‚úì PDF ($PDF_LAST_COMMIT) is current - no generation needed"
                continue
              else
                echo "  üîÑ ChordPro ($CHOPRO_LAST_COMMIT) is newer than PDF ($PDF_LAST_COMMIT) - needs regeneration"
              fi
            else
              echo "  üîÑ PDF exists in push but needs regeneration due to ChordPro changes"
            fi
          else
            echo "  ‚ûï No PDF exists - needs generation"
          fi
          
          # Add to list of PDFs that need generation
          if [ -z "$PDFS_NEEDED" ]; then
            PDFS_NEEDED="$chopro_file"
          else
            PDFS_NEEDED="$PDFS_NEEDED"$'\n'"$chopro_file"
          fi
        done < /tmp/changed_chopro.txt
        
        if [ -z "$PDFS_NEEDED" ]; then
          echo "‚ÑπÔ∏è All PDFs are current - no generation needed"
          echo "need_pdfs=false" >> $GITHUB_OUTPUT
        else
          echo "üìã ChordPro files needing PDF generation:"
          echo "$PDFS_NEEDED"
          echo "$PDFS_NEEDED" > /tmp/pdfs_needed.txt
          echo "need_pdfs=true" >> $GITHUB_OUTPUT
        fi
    
    - name: Install ChordPro and dependencies
      if: steps.check-pdfs.outputs.need_pdfs == 'true'
      run: |
        echo "üì¶ Installing ChordPro and dependencies..."
        sudo apt-get update
        sudo apt-get install -y cpanminus build-essential libpod-parser-perl
        sudo cpanm --notest App::Music::ChordPro
        
        # Verify installation
        echo "ChordPro version:"
        chordpro --version
    
    - name: Install genpdf-butler
      if: steps.check-pdfs.outputs.need_pdfs == 'true'
      run: |
        echo "üì¶ Installing genpdf-butler with pipx..."
        python -m pip install --upgrade pip
        pip install pipx
        pipx install genpdf-butler
        
        # Verify installation
        echo "genpdf-butler version:"
        genpdf-butler --version || echo "genpdf-butler installed successfully"
    
    - name: Generate PDFs
      if: steps.check-pdfs.outputs.need_pdfs == 'true'
      run: |
        echo "üî® Generating PDFs..."
        
        # Process each ChordPro file that needs PDF generation
        while IFS= read -r chopro_file; do
          if [ -z "$chopro_file" ] || [ ! -f "$chopro_file" ]; then
            continue
          fi
          
          # Determine PDF path
          pdf_file="${chopro_file%.*}.pdf"
          
          # Generate PDF (overwrite existing if present)
          if [ -f "$pdf_file" ]; then
            echo "  üîÑ Overwriting existing PDF: $pdf_file"
          else
            echo "  ‚ûï Creating new PDF: $pdf_file"
          fi
          
          echo "  üî® Generating PDF: $pdf_file"
          
          # Create output directory if needed
          mkdir -p "$(dirname "$pdf_file")"
          
          # Generate PDF using genpdf with a5 page size and chords on top
          genpdf --pagesize a5 --showchords top "$chopro_file" 2>/dev/null || {
            echo "  ‚ö†Ô∏è Failed to generate: $pdf_file"
            continue
          }
          
          # Verify PDF was created
          if [ -f "$pdf_file" ]; then
            echo "  ‚úÖ Generated: $pdf_file"
            # Add to git staging
            git add "$pdf_file"
          else
            echo "  ‚ö†Ô∏è PDF generation failed: $pdf_file"
          fi
        done < /tmp/pdfs_needed.txt
    
    - name: Commit generated PDFs
      run: |
        # Configure git
        git config --local user.email "action@github.com"
        git config --local user.name "PDF Generator Action"
        
        # Check if there are any staged files
        if git diff --cached --quiet; then
          echo "‚ÑπÔ∏è No PDFs were generated"
          exit 0
        fi
        
        # Count staged PDF files
        STAGED_PDFS=$(git diff --cached --name-only | grep '\.pdf$' | wc -l)
        echo "üìä Generated $STAGED_PDFS PDF(s)"
        
        # Create commit message with generated PDF list
        PDF_LIST=$(git diff --cached --name-only | grep '\.pdf$' | sed 's/^/- /' | tr '\n' ' ')
        
        # Commit the generated PDFs
        git commit -m "üéµ Auto-generate PDFs from ChordPro files - Generated $STAGED_PDFS PDF(s): $PDF_LIST"
        
        # Push back to repository
        git push origin ${{ github.ref_name }}
        
        echo "‚úÖ Generated PDFs committed and pushed"
    
    - name: Trigger Pages deployment
      if: success()
      uses: actions/github-script@v7
      with:
        script: |
          console.log('Triggering GitHub Pages deployment via repository dispatch...');
          try {
            await github.rest.repos.createDispatchEvent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              event_type: 'deploy-pages',
              client_payload: {
                ref: '${{ github.ref_name }}',
                triggered_by: 'auto-generate-pdfs',
                message: 'Deploy after PDF generation'
              }
            });
            console.log('‚úÖ Successfully triggered deployment via repository dispatch');
          } catch (error) {
            console.log('‚ö†Ô∏è Could not trigger deployment:', error.message);
            console.log('üìÑ PDFs were committed - deployment may trigger on next push');
          }
